import numpy as np
import re, struct, collections

#https://github.com/easy-electrophysiology/load-heka-python/blob/main/load_heka_python/trees/SharedTrees.py#L118


class Struct(object):
    """High-level wrapper around struct.Struct that makes it a bit easier to
    unpack large, nested structures.

    * Unpacks to dictionary allowing fields to be retrieved by name
    * Optionally massages field data on read
    * Handles arrays and nested structures

    *fields* must be a list of tuples like (name, format) or (name, format, function)
    where *format* must be a simple struct format string like 'i', 'd',
    '32s', or '4d'; or another Struct instance.

    *function* may be either a function that filters the data for that field
    or None to exclude the field altogether.

    If *size* is given, then an exception will be raised if the final struct size
    does not match the given size.

    Example::

        class MyStruct(Struct):
            field_info = [
                ('char_field', 'c'),                # single char
                ('char_array', '8c'),               # list of 8 chars
                ('str_field',  '8s', cstr),         # C string of len 8
                ('sub_struct', MyOtherStruct),      # dict generated by s2.unpack
                ('filler', '32s', None),            # ignored field
            ]
            size_check = 300

        fh = open(fname, 'rb')
        data = MyStruct(fh)

    """
    field_info = None
    size_check = None
    _fields_parsed = None



    def __init__(self, data, endian='<'):
        """Read the structure from *data* and return an ordered dictionary of
        fields.

        *data* may be a string or file.
        *endian* may be '<' or '>'
        """
        field_info = self._field_info()
        if not isinstance(data, (str, bytes)):
            data = data.read(self._le_struct.size)
        if endian == '<':
            items = self._le_struct.unpack(data)
        elif endian == '>':
            items = self._be_struct.unpack(data)
        else:
            raise ValueError('Invalid endian: %s' % endian)

        fields = collections.OrderedDict()

        i = 0
        for name, fmt, func in field_info:
            # pull item(s) out of the list based on format string
            if len(fmt) == 1 or fmt[-1] == 's':
                item = items[i]
                i += 1
            else:
                n = int(fmt[:-1])
                item = items[i:i+n]
                i += n

            # try unpacking sub-structure
            if isinstance(func, tuple):
                substr, func = func
                item = substr(item, endian)

            # None here means the field should be omitted
            if func is None:
                continue
            # handle custom massaging function
            if func is not True:
                item = func(item)
            fields[name] = item

            setattr(self, name, item)

        self.fields = fields

    @classmethod
    def _field_info(cls):
        if cls._fields_parsed is not None:
            return cls._fields_parsed

        fmt = ''
        fields = []
        for items in cls.field_info:
            if len(items) == 3:
                name, ifmt, func = items
            else:
                name, ifmt = items
                func = True

            if isinstance(ifmt, type) and issubclass(ifmt, Struct):
                func = (ifmt, func) # instructs to unpack with sub-struct before calling function
                ifmt = '%ds' % ifmt.size()
            elif len(ifmt) > 1 and re.match(r'\d*[xcbB?hHiIlLqQfdspP]', ifmt) is None:
                raise TypeError('Unsupported format string "%s"' % ifmt)

            fields.append((name, ifmt, func))
            fmt += ifmt
        cls._le_struct = struct.Struct('<' + fmt)
        cls._be_struct = struct.Struct('>' + fmt)
        cls._fields_parsed = fields
        print(cls._le_struct.size, cls.size_check)
        if cls.size_check is not None:
            assert cls._le_struct.size == cls.size_check
        return fields

    @classmethod
    def size(cls):
        cls._field_info()
        return cls._le_struct.size

    @classmethod
    def array(cls, x):
        """Return a new StructArray class of length *x* and using this struct
        as the array item type.
        """
        return type(cls.__name__+'[%d]'%x, (StructArray,),
                    {'item_struct': cls, 'array_size': x})

    def __repr__(self, indent=0):
        indent_str = '    '*indent
        r = indent_str + '%s(\n'%self.__class__.__name__
        if not hasattr(self, 'fields'):
            r = r[:-1] + '<initializing>)'
            return r
        for k,v in self.fields.items():
            if isinstance(v, Struct):
                r += indent_str + '    %s = %s\n' % (k, v.__repr__(indent=indent+1).lstrip())
            else:
                r += indent_str + '    %s = %r\n' % (k, v)
        r += indent_str + ')'
        return r

    def get_fields(self):
        """Recursively convert struct fields+values to nested dictionaries.
        """
        fields = self.fields.copy()
        for k,v in fields.items():
            if isinstance(v, StructArray):
                fields[k] = [x.get_fields() for x in v.array]
            elif isinstance(v, Struct):
                fields[k] = v.get_fields()
        return fields

class StructArray(Struct):
    item_struct = None
    array_size = None

    def __init__(self, data, endian='<'):
        if not isinstance(data, (str, bytes)):
            data = data.read(self.size())
        items = []
        isize = self.item_struct.size()
        for i in range(self.array_size):
            d = data[:isize]
            data = data[isize:]
            items.append(self.item_struct(d, endian))
        self.array = items

    def __getitem__(self, i):
        return self.array[i]

    @classmethod
    def size(self):
        return self.item_struct.size() * self.array_size

    def __repr__(self, indent=0):
        r = '    '*indent + '%s(\n' % self.__class__.__name__
        for item in self.array:
            r += item.__repr__(indent=indent+1) + ',\n'
        r += '    '*indent + ')'
        return r
    
class TreeNode(Struct):
    """Struct that also represents a node in a Pulse file tree.
    """
    def __init__(self, fh, pul, level=0):

        self.level = level
        self.children = []
        endian = pul.endian

        # The record structure in the file may differ from our expected structure
        # due to version differences, so we read the required number of bytes, and
        # then pad or truncate before unpacking the record. This will probably
        # result in corrupt data in some situations..
        realsize = pul.level_sizes[level]
        structsize = self.size()
        data = fh.read(realsize)
        diff = structsize - realsize
        if diff > 0:
            data = data + b'\0'*diff
        else:
            data = data[:structsize]

        # initialize struct data
        Struct.__init__(self, data, endian)

        # Next read the number of children
        nchild = struct.unpack(endian + 'i', fh.read(4))[0]
        level += 1
        if level >= len(pul.rectypes):
            return
        child_rectype = pul.rectypes[level]
        for i in range(nchild):
            self.children.append(child_rectype(fh, pul, level))


    def __getitem__(self, i):
        return self.children[i]

    def __len__(self):
        return len(self.children)

    def __iter__(self):
        return self.children.__iter__()

    def __repr__(self, indent=0):
        # Return a string describing this structure
        ind = '    '*indent
        srep = Struct.__repr__(self, indent)[:-1]  # exclude final parenthese
        srep += ind + '    children = %d,\n' % len(self)
        #srep += ind + 'children = [\n'
        #for ch in self:
            #srep += ch.__repr__(indent=indent+1) + ',\n'
        srep += ind + ')'
        return srep



def cstr(byt):
    """Convert C string bytes to python string.
    """
    try:
        ind = byt.index(b'\0')
    except ValueError:
        return byt
    return byt[:ind].decode('utf-8', errors='ignore')


class GroupRecord(TreeNode):
    field_info =  [
        ("GrMark", "i"),  # (* INT32 *)
        ("GrLabel", "32s", cstr),  # (* String32Size *)
        ("GrText", "80s", cstr),  # (* String32Size *)
        ("GrExperimentNumber", "i"),  # (* INT32 *)
        ("GrGroupCount", "i"),  # (* INT32 *)
        ("GrCRC", "I"),  # (* CARD32 *)
    ]
    size_check = 128

class Description:
    def __init__(self, n):

        self.description = ()
        self.size = int
        self.n = n

    def get_size(self):
        return self.size * self.n

    def get_description(self):
        return self.description * self.n


class UserParamDescrType(Description):
    def __init__(self, n=1):
        super(UserParamDescrType, self).__init__(n)

        self.description = [
            ("Name", "32s", cstr),
            ("Unit", "8s", cstr),
        ]

        self.size = 40

class SeriesRecord(TreeNode):
    field_info = [
            ("SeMark", "i"),  # (* INT32 *)
            ("SeLabel", "32s", cstr),  # (* String32Type *)
            ("SeComment", "80s", cstr),  # (* String80Type *)
            ("SeSeriesCount", "i"),  # (* INT32 *)
            ("SeNumberSweeps", "i"),  # (* INT32 *)
            ("SeAmplStateOffset", "i"),  # (* INT32 *)
            ("SeAmplStateSeries", "i"),  # (* INT32 *)
            ("SeMethodTag", "i"),  # (* INT32 *)
            ("SeTime", "d"),  # * LONGREAL *)
            ("SePageWidth", "d"),  # * LONGREAL *)
            ("SeSwUserParamDescr", "160s", UserParamDescrType(4)),  # (* ARRAY[0..3] OF UserParamDescrType = 4*40 *)
            ("SeMethodName", "32s", cstr),  # (* String32Type *)
            ("SeSeUserParams1", "4d"),  # (* ARRAY[0..3] OF LONGREAL *)
            ("SeLockInParams", "96s"),#. LockInParams_v9()),  # (* SeLockInSize = 96, see "Pulsed.de" *)
            ("SeAmplifierState", "400s"),#, AmplifierState_v9()),  # (* AmplifierStateSize = 400 *)
            ("SeUsername", "80s", cstr),  # (* String80Type *)
            ("SeSeUserParamDescr1", "160s", UserParamDescrType(4)),  # (* ARRAY[0..3] OF UserParamDescrType = 4*40 *)
            ("SeFiller1", "i"),  # (* INT32 *)
            ("SeCRC", "I"),  # (* CARD32 *)
            ("SeSeUserParams2", "4d"),  # (* ARRAY[0..3] OF LONGREAL *)
            ("SeSeUserParamDescr2", "160s", UserParamDescrType(4)),  # (* ARRAY[0..3] OF UserParamDescrType = 4*40 *)
            ("SeScanParams", "96s", cstr),  # (* ScanParamsSize = 96 *)
        ]
    check_size = 1408


class Pulsed(TreeNode):
    field_info = [
        ("RoVersion", "i"),  # (* INT32 *)
        ("RoMark", "i"),  # (* INT32 *)
        ("RoVersionName", "32s", cstr),  # (* String32Type *)
        ("RoAuxFileName", "80s", cstr),  # (* String80Type *)
        ("RoRootText", "400s", cstr),  # (* String400Type *)
        ("RoStartTime", "d"),  # (* LONGREAL *)
        ("RoMaxSamples", "i"),  # (* INT32 *)
        ("RoCRC", "I"),  # (* CARD32 *)
        ("RoFeatures", "h"),  # (* SET16 *)
        ("RoFiller1", "h"),  # (* INT16 *)
        ("RoFiller2", "i"),  # (* INT32 *)
    ]
    size_check = 544

    rectypes = [
        None,
        GroupRecord,
        SeriesRecord,
        #SweepRecord,
        #TraceRecord
    ]

    def __init__(self, file_name, offset=0, size=None):
        fh = open(file_name, 'rb')
        fh.seek(offset)

        # read .pul header
        magic = fh.read(4)
        if magic == b'eerT':
            self.endian = '<'
        elif magic == b'Tree':
            self.endian = '>'
        else:
            raise RuntimeError('Bad file magic: %s' % magic)

        levels = struct.unpack(self.endian + 'i', fh.read(4))[0]
        # read size of each level (one int per level)
        self.level_sizes = []
        for i in range(levels):
            size = struct.unpack(self.endian + 'i', fh.read(4))[0]
            self.level_sizes.append(size)

        TreeNode.__init__(self, fh, self)


def read_the_stupid_pulse():

    pathname = "/home/data-science/Downloads/test_data_dat1/"
    file_name = "PATCH4_2023278_07"
    suffix = ".dat"

    b = Pulsed(pathname+file_name+".pul")
    return Pulsed